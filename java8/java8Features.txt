java 8 feature -> 2014
latest 18 version 


python, R, scala 
10 lines of code ->
100 lines of java -> 

Less number of code -> Functional programming


 					 
1. lambda expression
2. functional interface
3. default/static methods
4. predefined  functional interfaces
     predicate
     consumer
     supplier
     function
5.Double colon operator (::)
     for method reference purpose
     for constructor reference. 
6. streams, parallel streams
7. optional classes ( to avoid null pointer exce)
8. date time api ( util.date or sql.date)


1. lambda expression
  LISP -> used lambda 
  lambda -> python, c , c++ 
   not specific to java, came lately 
   -> lambda expression
   objective: to bring benefits of functional programming into javaa
   ->
   anonymous function
 -> no name/ nameless
 -> without r type, without modifier, without name -> 
 
 
 public void printSomething(){
 System.out.println("Hello");
 }


no return type, no modifier, no method name 


reduction in lambda expression:

  ()-> {System.out.println("Hello");}

 ()-> System.out.println("Hello");

-----------------example 1 ----------------
public void square(int a){
System.out.println(a*a);
}

reduction in lambda expression:

  ()-> {System.out.println("Hello");}

 ()-> System.out.println("Hello");
---------------example 2 ------------------
public void square(int a){
System.out.println(a*a);
}

 (int a) -> {System.out.println(a*a);}
(int a) -> System.out.println(a*a);
(a) -> System.out.println(a*a);
------------------------------

EG: 2

 public void m1(int a, int b){
 sysout(a+b);
 }
   ( a, b) -> sysout(a+b); //solution
 
 
 EG 3:
 public int squareIt(int n){
 return n*n;
 }

    (n) ->  n*n;
 
 EG: 4
 public int  m1(String s){
 return s.length()
 }
 
    ( s) -> { s.length() };
 EG: 5
 public void printName(String name){
System.out.println(name);
}
(name)-> name;






basics about abstract class
-> can have both abstract and non abstract methods

interface:
-> all methods are abstract methods 

